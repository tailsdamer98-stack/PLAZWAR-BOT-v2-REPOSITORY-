#README ENG 
We are given two pieces of code. The first one is a bot code that is partially working but needs fixes and additional functionality.
The second one is an example code that we should base the transfer on.

Task: Combine the functionality from the first code (PL system, translation, top, profile, message rewards)
into the structure of the second code (commands /start, /help, /proshop, /profile, /give and message handling in chats).

Requirements:

The bot must be silent in other chats (except plazchat).

In plazchat, the bot only responds to triggers and commands (profile, top, transfer, info, balance) and awards PL for messages.

In private messages, the bot works fully.

User IDs must be permanent (not change on every restart).

In the /help command, use bold and quoting for certain parts.

In the /proshop command, send an image if available, or text.

Implement a system for awarding PL for messages in plazchat (after 100 messages).

Implement PL transfer (command /give and the word "–ø–µ—Ä–µ–¥–∞—Ç—å" in plazchat).

For unknown commands in private messages, the bot should write "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞".

Also, fix the errors in the first code and make sure the bot doesn't crash.

Plan:

We'll create a data structure for users (a dictionary in memory, but we can switch to a database in the future).

Implement functions for working with users (get_or_create_user, transfer_pl, get_top_users).

Set up command handlers for private messages and for the plazchat chat.

In plazchat, we'll handle text commands (profile, top, transfer, info, balance) and award PL for messages.

In private messages, we'll handle commands (/start, /help, /proshop, /profile, /give, /top) and for unknown commands (including text) respond with "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞".

The bot should not react in other chats.

Important points:

In plazchat, bot commands can be written without a slash (e.g., "–ø—Ä–æ—Ñ–∏–ª—å"), and in private only with a slash.

In plazchat, the bot should also ignore slash commands (as in the first code) so as not to interfere with other bots.

We'll note that in the first code there is handling of commands in active chats (plazchat and test group). We'll leave only plazchat.

Fixes:

In the /help command, do proper formatting with bold and quotes.

In the /profile command, display correct data (messages, PL, rank).

When awarding PL in plazchat: after 100 messages, award 0.5 PL per message.

Let's start writing the code.

Note: The code will be long, so we'll try to structure it.

Steps:

Import libraries.

Set constants.

Create data structures for storing users.

Define helper functions.

Create command and message handlers.

Important: To avoid errors with images, we'll use try-except.

Note that in the second code, parse_mode='HTML' is used, so we can use HTML tags for formatting.

For quoting in HTML, we use the <blockquote> tag.

The /help command must be formatted according to the requirements.

Also, note that in plazchat, the bot should be silent on all messages except specific commands (and triggers for joining/leaving).
But at the same time, award PL for every message (with anti-flood).

In private messages, the bot responds to messages without commands (and without a slash) with "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞".

Implementation:

In plazchat:

Handle text commands (–ø—Ä–æ—Ñ–∏–ª—å, —Ç–æ–ø, –±–∞–ª–∞–Ω—Å, –∏–Ω—Ñ, –ø–µ—Ä–µ–¥–∞—Ç—å) and triggers (–≤—Å—Ç—É–ø–∏—Ç—å, –≤—ã–π—Ç–∏).

Award PL for messages (with anti-flood and a threshold of 100 messages).

Ignore slash commands (so as not to interfere with other bots).

In private messages:

Handle slash commands (/start, /help, /proshop, /profile, /give, /top).

For all other text messages (without a slash), respond with "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞".

In other chats, the bot should not react at all.

To do this, we need to set up filters in the handlers correctly.

Also, we need to make sure that in plazchat, commands that are written with a slash (e.g., /start) are ignored by the bot (but can be handled by other bots).

In the first code, for this purpose, they used the function ignore_commands_active_chat, which did nothing.

We will use filters to not intercept slash commands in plazchat.

Let's start.

Note: Due to the large volume of code, I will write the code in parts, but try to make it whole.

WE HAVE TWO PIECES OF CODE. THE FIRST IS BOT CODE THAT IS PARTIALLY WORKING BUT NEEDS FIXES AND ADDITIONAL FUNCTIONALITY.
THE SECOND IS EXAMPLE CODE THAT WE SHOULD USE AS A BASIS FOR TRANSFER.

TASK: COMBINE FUNCTIONALITY FROM THE FIRST CODE (PL SYSTEM, TRANSFER, TOP, PROFILE, MESSAGE REWARDS)
INTO THE STRUCTURE OF THE SECOND CODE (COMMANDS /START, /HELP, /PROSHOP, /PROFILE, /GIVE AND MESSAGE HANDLING IN CHATS).

REQUIREMENTS:

BOT SHOULD BE SILENT IN OTHER CHATS (EXCEPT PLAZCHAT).

IN PLAZCHAT BOT RESPONDS ONLY TO TRIGGERS AND COMMANDS (PROFILE, TOP, TRANSFER, INFO, BALANCE) AND AWARDS PL FOR MESSAGES.

IN PRIVATE MESSAGES BOT WORKS FULLY.

USER IDS MUST BE PERMANENT (NOT CHANGE ON EVERY RESTART).

IN /HELP COMMAND USE BOLD FONT AND QUOTING FOR CERTAIN PARTS.

IN /PROSHOP COMMAND SEND AN IMAGE IF AVAILABLE, OR TEXT.

IMPLEMENT SYSTEM FOR AWARDING PL FOR MESSAGES IN PLAZCHAT (AFTER 100 MESSAGES).

IMPLEMENT PL TRANSFER (COMMAND /GIVE AND WORD "–ü–ï–†–ï–î–ê–¢–¨" IN PLAZCHAT).

FOR UNKNOWN COMMANDS IN PRIVATE MESSAGES BOT SHOULD WRITE "‚ùì UNKNOWN COMMAND".

ALSO FIX ERRORS IN FIRST CODE AND MAKE SURE BOT DOESN'T CRASH.

PLAN:

CREATE DATA STRUCTURE FOR USERS (DICTIONARY IN MEMORY, BUT CAN SWITCH TO DATABASE IN FUTURE).

IMPLEMENT FUNCTIONS FOR WORKING WITH USERS (GET_OR_CREATE_USER, TRANSFER_PL, GET_TOP_USERS).

SET UP COMMAND HANDLERS FOR PRIVATE MESSAGES AND FOR PLAZCHAT CHAT.

IN PLAZCHAT HANDLE TEXT COMMANDS (PROFILE, TOP, TRANSFER, INFO, BALANCE) AND AWARD PL FOR MESSAGES.

IN PRIVATE MESSAGES HANDLE COMMANDS (/START, /HELP, /PROSHOP, /PROFILE, /GIVE, /TOP) AND FOR UNKNOWN COMMANDS (INCLUDING TEXT) RESPOND WITH "‚ùì UNKNOWN COMMAND".

BOT SHOULD NOT REACT IN OTHER CHATS.

IMPORTANT POINTS:

IN PLAZCHAT BOT COMMANDS CAN BE WRITTEN WITHOUT SLASH (E.G., "PROFILE"), AND IN PRIVATE ONLY WITH SLASH.

IN PLAZCHAT BOT SHOULD ALSO IGNORE SLASH COMMANDS (AS IN FIRST CODE) SO AS NOT TO INTERFERE WITH OTHER BOTS.

NOTE THAT IN FIRST CODE THERE IS HANDLING OF COMMANDS IN ACTIVE CHATS (PLAZCHAT AND TEST GROUP). WE'LL LEAVE ONLY PLAZCHAT.

FIXES:

IN /HELP COMMAND DO PROPER FORMATTING WITH BOLD AND QUOTES.

IN /PROFILE COMMAND DISPLAY CORRECT DATA (MESSAGES, PL, RANK).

WHEN AWARDING PL IN PLAZCHAT: AFTER 100 MESSAGES AWARD 0.5 PL PER MESSAGE.

LET'S START WRITING CODE.

NOTE: CODE WILL BE LONG, SO WE'LL TRY TO STRUCTURE IT.

STEPS:

IMPORT LIBRARIES.

SET CONSTANTS.

CREATE DATA STRUCTURES FOR STORING USERS.

DEFINE HELPER FUNCTIONS.

CREATE COMMAND AND MESSAGE HANDLERS.

IMPORTANT: TO AVOID ERRORS WITH IMAGES, USE TRY-EXCEPT.

NOTE THAT IN SECOND CODE, PARSE_MODE='HTML' IS USED, SO WE CAN USE HTML TAGS FOR FORMATTING.

FOR QUOTING IN HTML USE <BLOCKQUOTE> TAG.

/HELP COMMAND MUST BE FORMATTED ACCORDING TO REQUIREMENTS.

ALSO NOTE THAT IN PLAZCHAT BOT SHOULD BE SILENT ON ALL MESSAGES EXCEPT SPECIFIC COMMANDS (AND TRIGGERS FOR JOINING/LEAVING).
BUT AT SAME TIME AWARD PL FOR EVERY MESSAGE (WITH ANTI-FLOOD).

IN PRIVATE MESSAGES BOT RESPONDS TO MESSAGES WITHOUT COMMANDS (AND WITHOUT SLASH) WITH "‚ùì UNKNOWN COMMAND".

IMPLEMENTATION:

IN PLAZCHAT:

HANDLE TEXT COMMANDS (PROFILE, TOP, BALANCE, INFO, TRANSFER) AND TRIGGERS (JOIN, LEAVE).

AWARD PL FOR MESSAGES (WITH ANTI-FLOOD AND THRESHOLD OF 100 MESSAGES).

IGNORE SLASH COMMANDS (SO AS NOT TO INTERFERE WITH OTHER BOTS).

IN PRIVATE MESSAGES:

HANDLE SLASH COMMANDS (/START, /HELP, /PROSHOP, /PROFILE, /GIVE, /TOP).

FOR ALL OTHER TEXT MESSAGES (WITHOUT SLASH), RESPOND WITH "‚ùì UNKNOWN COMMAND".

IN OTHER CHATS BOT SHOULD NOT REACT AT ALL.

TO DO THIS, NEED TO SET UP FILTERS IN HANDLERS CORRECTLY.

ALSO NEED TO MAKE SURE THAT IN PLAZCHAT COMMANDS THAT ARE WRITTEN WITH SLASH (E.G., /START) ARE IGNORED BY BOT (BUT CAN BE HANDLED BY OTHER BOTS).

IN FIRST CODE FOR THIS PURPOSE THEY USED FUNCTION IGNORE_COMMANDS_ACTIVE_CHAT, WHICH DID NOTHING.

WE WILL USE FILTERS TO NOT INTERCEPT SLASH COMMANDS IN PLAZCHAT.

LET'S START.

NOTE: DUE TO LARGE VOLUME OF CODE, I WILL WRITE CODE IN PARTS, BUT TRY TO MAKE IT WHOLE.

CONCEPT OF TRIGGER WORD SYSTEM FOR TELEGRAM BOT PLAZWAR
üöÄ FULL CODE WITH TRIGGERS (TELEBOT API):
PYTHON
IMPORT TELEBOT
IMPORT JSON
IMPORT TIME
IMPORT OS
FROM DATETIME IMPORT DATETIME
FROM TYPING IMPORT DICT, LIST, OPTIONAL

========== CONFIGURATION ==========
BOT_TOKEN = '8553117129:AAGK879G24RD7QADWLK5BHL9DOK2RL9ZFY–ê'
BOT = TELEBOT.TELEBOT(BOT_TOKEN, PARSE_MODE='HTML')

CHAT ID FOR PLAZCHAT
PLAZCHAT_CHAT_ID = -1002222950483 # REPLACE WITH REAL CHAT ID @PLAZCHAT

FILE PATHS
USERS_FILE = 'USERS.JSON'
TRIGGERS_FILE = 'TRIGGERS.JSON'
WARNINGS_FILE = 'WARNINGS.JSON'

TRIGGER SYSTEM SETTINGS
WARNINGS_LIMIT = 3 # MAXIMUM WARNINGS BEFORE BAN
BAN_DURATION = 3600 # BAN DURATION IN SECONDS (1 HOUR)

========== DATA STRUCTURES ==========
CLASS DATASTORAGE:
"""CLASS FOR WORKING WITH DATA"""

text
@STATICMETHOD
DEF LOAD_JSON(FILENAME: STR, DEFAULT=NONE):
    """LOAD DATA FROM JSON FILE"""
    TRY:
        IF OS.PATH.EXISTS(FILENAME):
            WITH OPEN(FILENAME, 'R', ENCODING='UTF-8') AS F:
                RETURN JSON.LOAD(F)
    EXCEPT EXCEPTION AS E:
        PRINT(F"ERROR LOADING {FILENAME}: {E}")
    RETURN DEFAULT OR {}

@STATICMETHOD
DEF SAVE_JSON(FILENAME: STR, DATA):
    """SAVE DATA TO JSON FILE"""
    TRY:
        WITH OPEN(FILENAME, 'W', ENCODING='UTF-8') AS F:
            JSON.DUMP(DATA, F, ENSURE_ASCII=FALSE, INDENT=2)
    EXCEPT EXCEPTION AS E:
        PRINT(F"ERROR SAVING {FILENAME}: {E}")
========== TRIGGER SYSTEM ==========
CLASS TRIGGERSYSTEM:
"""TRIGGER WORD AND MODERATION SYSTEM"""

text
DEF __INIT__(SELF):
    SELF.TRIGGERS = DATASTORAGE.LOAD_JSON(TRIGGERS_FILE, [])
    SELF.WARNINGS = DATASTORAGE.LOAD_JSON(WARNINGS_FILE, {})
    SELF.USERS = DATASTORAGE.LOAD_JSON(USERS_FILE, {})
    
    # DEFAULT TRIGGERS (IF FILE IS EMPTY)
    IF NOT SELF.TRIGGERS:
        SELF.TRIGGERS = [
            "ADVERTISEMENT", "SPAM", "INSULT", "PROFANITY", 
            "SCAM", "DECEPTION", "FRAUD", "PORNOGRAPHY", 
            "DRUGS", "WEAPONS", "VIOLENCE", "FRAUD"
        ]
        DATASTORAGE.SAVE_JSON(TRIGGERS_FILE, SELF.TRIGGERS)

DEF CHECK_MESSAGE(SELF, MESSAGE) -> LIST[STR]:
    """CHECK MESSAGE FOR TRIGGERS"""
    IF NOT MESSAGE.TEXT:
        RETURN []
    
    TEXT = MESSAGE.TEXT.LOWER()
    FOUND_TRIGGERS = []
    
    FOR TRIGGER IN SELF.TRIGGERS:
        IF TRIGGER IN TEXT:
            FOUND_TRIGGERS.APPEND(TRIGGER)
    
    RETURN FOUND_TRIGGERS

DEF ADD_WARNING(SELF, USER_ID: INT) -> INT:
    """ADD WARNING TO USER"""
    USER_ID_STR = STR(USER_ID)
    
    IF USER_ID_STR NOT IN SELF.WARNINGS:
        SELF.WARNINGS[USER_ID_STR] = {
            'COUNT': 0,
            'HISTORY': [],
            'LAST_WARNING': NONE
        }
    
    SELF.WARNINGS[USER_ID_STR]['COUNT'] += 1
    SELF.WARNINGS[USER_ID_STR]['LAST_WARNING'] = TIME.TIME()
    SELF.WARNINGS[USER_ID_STR]['HISTORY'].APPEND({
        'TIME': TIME.TIME(),
        'REASON': 'TRIGGER WORD'
    })
    
    DATASTORAGE.SAVE_JSON(WARNINGS_FILE, SELF.WARNINGS)
    RETURN SELF.WARNINGS[USER_ID_STR]['COUNT']

DEF GET_WARNINGS(SELF, USER_ID: INT) -> DICT:
    """GET WARNING INFORMATION"""
    USER_ID_STR = STR(USER_ID)
    RETURN SELF.WARNINGS.GET(USER_ID_STR, {'COUNT': 0, 'HISTORY': []})

DEF RESET_WARNINGS(SELF, USER_ID: INT) -> BOOL:
    """RESET USER WARNINGS"""
    USER_ID_STR = STR(USER_ID)
    IF USER_ID_STR IN SELF.WARNINGS:
        DEL SELF.WARNINGS[USER_ID_STR]
        DATASTORAGE.SAVE_JSON(WARNINGS_FILE, SELF.WARNINGS)
        RETURN TRUE
    RETURN FALSE

DEF ADD_TRIGGER(SELF, TRIGGER: STR) -> BOOL:
    """ADD TRIGGER"""
    IF TRIGGER.LOWER() NOT IN SELF.TRIGGERS:
        SELF.TRIGGERS.APPEND(TRIGGER.LOWER())
        DATASTORAGE.SAVE_JSON(TRIGGERS_FILE, SELF.TRIGGERS)
        RETURN TRUE
    RETURN FALSE

DEF REMOVE_TRIGGER(SELF, TRIGGER: STR) -> BOOL:
    """REMOVE TRIGGER"""
    IF TRIGGER.LOWER() IN SELF.TRIGGERS:
        SELF.TRIGGERS.REMOVE(TRIGGER.LOWER())
        DATASTORAGE.SAVE_JSON(TRIGGERS_FILE, SELF.TRIGGERS)
        RETURN TRUE
    RETURN FALSE

DEF GET_TRIGGERS(SELF) -> LIST[STR]:
    """GET LIST OF ALL TRIGGERS"""
    RETURN SELF.TRIGGERS
========== USER SYSTEM ==========
CLASS USERSYSTEM:
"""USER SYSTEM AND PL AWARDING"""

text
DEF __INIT__(SELF):
    SELF.USERS = DATASTORAGE.LOAD_JSON(USERS_FILE, {})
    SELF.LAST_MESSAGE_TIME = {}
    SELF.PL_REWARD = 0.5
    SELF.MESSAGE_THRESHOLD = 100

DEF GET_OR_CREATE_USER(SELF, TELEGRAM_ID: INT, USERNAME: STR = "") -> DICT:
    """GET OR CREATE USER"""
    USER_ID_STR = STR(TELEGRAM_ID)
    
    IF USER_ID_STR NOT IN SELF.USERS:
        # ASSIGN ID IN ORDER
        NEW_ID = LEN(SELF.USERS) + 1000
        USERNAME_CLEAN = USERNAME.REPLACE('@', '') IF USERNAME ELSE F"USER{TELEGRAM_ID}"
        
        SELF.USERS[USER_ID_STR] = {
            'USERNAME': USERNAME_CLEAN,
            'MESSAGES': 0,
            'PL': 0.0,
            'USER_ID': NEW_ID,
            'REGISTERED': DATETIME.NOW().ISOFORMAT(),
            'CLAN': NONE,
            'STRIKES': 0,
            'LEVEL': 1,
            'LAST_ACTIVE': TIME.TIME()
        }
        DATASTORAGE.SAVE_JSON(USERS_FILE, SELF.USERS)
    
    ELIF USERNAME AND '@' IN USERNAME:
        # UPDATE USERNAME IF HAS @
        SELF.USERS[USER_ID_STR]['USERNAME'] = USERNAME.REPLACE('@', '')
        DATASTORAGE.SAVE_JSON(USERS_FILE, SELF.USERS)
    
    RETURN SELF.USERS[USER_ID_STR]

DEF ADD_MESSAGE(SELF, TELEGRAM_ID: INT) -> FLOAT:
    """ADD MESSAGE AND AWARD PL"""
    USER = SELF.GET_OR_CREATE_USER(TELEGRAM_ID)
    USER['MESSAGES'] += 1
    USER['LAST_ACTIVE'] = TIME.TIME()
    
    # AWARD PL AFTER 100 MESSAGES
    IF USER['MESSAGES'] >= SELF.MESSAGE_THRESHOLD:
        PL_TO_ADD = SELF.PL_REWARD
        USER['PL'] = ROUND(USER.GET('PL', 0) + PL_TO_ADD, 2)
    
    DATASTORAGE.SAVE_JSON(USERS_FILE, SELF.USERS)
    RETURN USER['PL']

DEF TRANSFER_PL(SELF, SENDER_ID: INT, TARGET_ID: INT, AMOUNT: FLOAT) -> STR:
    """TRANSFER PL BETWEEN USERS"""
    TRY:
        IF AMOUNT <= 0:
            RETURN "‚ùóÔ∏èTRANSFER AMOUNT MUST BE GREATER THAN 0!"
        
        SENDER = SELF.GET_OR_CREATE_USER(SENDER_ID)
        
        IF SENDER['PL'] < AMOUNT:
            RETURN F"‚ùóÔ∏èINSUFFICIENT PL! YOU HAVE: {SENDER['PL']:.2F}"
        
        # FIND RECIPIENT BY USER_ID
        TARGET_USER = NONE
        TARGET_TELEGRAM_ID = NONE
        
        FOR TG_ID, USER_DATA IN SELF.USERS.ITEMS():
            IF USER_DATA['USER_ID'] == TARGET_ID:
                TARGET_USER = USER_DATA
                TARGET_TELEGRAM_ID = INT(TG_ID)
                BREAK
        
        IF NOT TARGET_USER:
            RETURN F"‚ùìPLAYER WITH ID {TARGET_ID} NOT FOUND"
        
        # PERFORM TRANSFER
        SENDER['PL'] = ROUND(SENDER['PL'] - AMOUNT, 2)
        TARGET_USER['PL'] = ROUND(TARGET_USER.GET('PL', 0) + AMOUNT, 2)
        
        # UPDATE RECIPIENT DATA
        SELF.USERS[STR(TARGET_TELEGRAM_ID)] = TARGET_USER
        DATASTORAGE.SAVE_JSON(USERS_FILE, SELF.USERS)
        
        RETURN F"‚úÖ TRANSFERRED {AMOUNT:.2F} PL TO USER {TARGET_USER['USERNAME']} (ID: {TARGET_ID})"
    
    EXCEPT EXCEPTION AS E:
        RETURN F"‚ùå TRANSFER ERROR: {STR(E)}"

DEF GET_TOP_USERS(SELF, LIMIT: INT = 10) -> STR:
    """GET TOP USERS"""
    IF NOT SELF.USERS:
        RETURN "üìä NO ACTIVE USERS YET"
    
    # SORT BY PL
    SORTED_USERS = SORTED(
        SELF.USERS.ITEMS(),
        KEY=LAMBDA X: X[1].GET('PL', 0),
        REVERSE=TRUE
    )[:LIMIT]
    
    RESULT = "üèÜ <B>TOP PLAYERS BY PL:</B>\N\N"
    FOR I, (TELEGRAM_ID, USER_DATA) IN ENUMERATE(SORTED_USERS, 1):
        USERNAME = USER_DATA['USERNAME']
        PL = USER_DATA.GET('PL', 0)
        USER_ID = USER_DATA['USER_ID']
        RESULT += F"{I}. <B>{USERNAME}</B> (ID: {USER_ID}) - {PL:.2F} PL\N"
    
    RETURN RESULT

DEF ANTI_FLOOD(SELF, USER_ID: INT, DELAY: INT = 2) -> BOOL:
    """CHECK FOR FLOOD"""
    CURRENT_TIME = TIME.TIME()
    
    IF USER_ID IN SELF.LAST_MESSAGE_TIME:
        TIME_DIFF = CURRENT_TIME - SELF.LAST_MESSAGE_TIME[USER_ID]
        IF TIME_DIFF < DELAY:
            RETURN FALSE
    
    SELF.LAST_MESSAGE_TIME[USER_ID] = CURRENT_TIME
    RETURN TRUE
========== SYSTEM INITIALIZATION ==========
TRIGGER_SYSTEM = TRIGGERSYSTEM()
USER_SYSTEM = USERSYSTEM()

========== ADMINISTRATION FUNCTIONS ==========
ADMIN_IDS = [] # ADD ADMIN IDS HERE

DEF IS_ADMIN(USER_ID: INT) -> BOOL:
"""CHECK IF USER IS ADMINISTRATOR"""
RETURN USER_ID IN ADMIN_IDS

========== COMMAND HANDLERS ==========
COMMAND /START
@BOT.MESSAGE_HANDLER(COMMANDS=['START'])
DEF START_COMMAND(MESSAGE):
CHAT_TYPE = MESSAGE.CHAT.TYPE

text
IF CHAT_TYPE == 'PRIVATE':
    WELCOME_TEXT = """<B>üëã WELCOME TO PLAZWAR!</B>
I AM BOT FOR GAME CHAT @PLAZCHAT
HERE YOU CAN:
‚Ä¢ EARN PL FOR ACTIVITY IN CHAT
‚Ä¢ TRANSFER PL TO OTHER PLAYERS
‚Ä¢ VIEW PLAYER RATINGS
‚Ä¢ MANAGE CLANS

<B>MAIN COMMANDS:</B>
/PROFILE - YOUR PROFILE
/HELP - DETAILED HELP
/PROSHOP - SHOP
/TOP - TOP PLAYERS
/GIVE - TRANSFER PL

<B>ADMIN COMMANDS (IF ACCESS):</B>
/TRIGGERS - TRIGGER MANAGEMENT
/WARNINGS - WARNINGS
/BAN - BAN USER"""

text
    BOT.REPLY_TO(MESSAGE, WELCOME_TEXT, PARSE_MODE='HTML')

ELIF MESSAGE.CHAT.ID == PLAZCHAT_CHAT_ID:
    BOT.REPLY_TO(MESSAGE, "ü§ñ BOT ACTIVE IN THIS CHAT! USE TEXT COMMANDS WITHOUT '/'")
COMMAND /HELP
@BOT.MESSAGE_HANDLER(COMMANDS=['HELP'])
DEF HELP_COMMAND(MESSAGE):
IF MESSAGE.CHAT.TYPE == 'PRIVATE':
HELP_TEXT = """<B>üìö HELP AND COMMANDS</B>

<B>1Ô∏è‚É£ PL ‚Äì POINTS LABOR</B>
‚Ä¢ PL AWARDED FOR ACTIVITY IN CHAT @PLAZCHAT
‚Ä¢ AFTER 100 MESSAGES: +0.5 PL FOR EACH MESSAGE
‚Ä¢ PL BURN AFTER 7 DAYS OF INACTIVITY

<B>2Ô∏è‚É£ CLANS</B>

<BLOCKQUOTE>‚Ä¢ CLAN CREATION: 3000 PL ‚Ä¢ JOIN: WRITE IN CHAT "JOIN [CLAN NAME]" ‚Ä¢ LEAVE: WRITE "LEAVE [CLAN NAME]" ‚Ä¢ MAXIMUM: 20 PEOPLE IN CLAN ‚Ä¢ LEVELS: UPGRADED BY MESSAGE EXPERIENCE ‚Ä¢ RAIDS: COMMAND /RAID TO ATTACK OTHER CLANS</BLOCKQUOTE>
<B>3Ô∏è‚É£ MAIN COMMANDS</B>
‚Ä¢ <B>/PROFILE</B> - YOUR PROFILE
‚Ä¢ <B>/TOP</B> - TOP PLAYERS
‚Ä¢ <B>/GIVE [ID] [AMOUNT]</B> - TRANSFER PL
‚Ä¢ <B>/PROSHOP</B> - ITEM SHOP
‚Ä¢ <B>/CLAN</B> - CLAN MANAGEMENT

<B>4Ô∏è‚É£ IN CHAT @PLAZCHAT</B>
‚Ä¢ <B>PROFILE</B> - SHOW PROFILE
‚Ä¢ <B>TOP</B> - TOP PLAYERS
‚Ä¢ <B>BALANCE</B> - YOUR PL BALANCE
‚Ä¢ <B>INFO [ID]</B> - PLAYER INFORMATION
‚Ä¢ <B>TRANSFER [ID] [AMOUNT]</B> - TRANSFER PL

<B>5Ô∏è‚É£ ADMIN COMMANDS</B>
‚Ä¢ <B>/TRIGGERS</B> - TRIGGER MANAGEMENT
‚Ä¢ <B>/WARNINGS @USER</B> - USER WARNINGS
‚Ä¢ <B>/BAN @USER</B> - BAN USER
‚Ä¢ <B>/UNBAN @USER</B> - UNBAN USER"""

text
    BOT.REPLY_TO(MESSAGE, HELP_TEXT, PARSE_MODE='HTML')
COMMAND /PROFILE
@BOT.MESSAGE_HANDLER(COMMANDS=['PROFILE'])
DEF PROFILE_COMMAND(MESSAGE):
USER = USER_SYSTEM.GET_OR_CREATE_USER(
MESSAGE.FROM_USER.ID,
MESSAGE.FROM_USER.USERNAME OR MESSAGE.FROM_USER.FIRST_NAME
)

text
# DETERMINE RANK
MESSAGES = USER['MESSAGES']
IF MESSAGES < 100:
    RANK = "NOVICE"
    PROGRESS = F"{MESSAGES}/100"
ELIF MESSAGES < 500:
    RANK = "WARRIOR"
    PROGRESS = F"{MESSAGES}/500"
ELIF MESSAGES < 1000:
    RANK = "VETERAN"
    PROGRESS = F"{MESSAGES}/1000"
ELSE:
    RANK = "LEGEND"
    PROGRESS = F"{MESSAGES}+"

PROFILE_TEXT = F"""<B>üë§ PLAYER PROFILE</B>
üöµ‚Äç‚ôÄÔ∏è <B>NICKNAME:</B> {USER['USERNAME']}
ü™™ <B>ID:</B> {USER['USER_ID']}
‚öîÔ∏è <B>RANK:</B> {RANK} ({PROGRESS})
üí∑ <B>PL:</B> {USER['PL']:.2F}
üè∞ <B>CLAN:</B> {USER['CLAN'] OR 'NONE'}
üé≥ <B>STRIKES:</B> {USER['STRIKES']} // 0 OPEN
üìÖ <B>REGISTRATION:</B> {DATETIME.FROMISOFORMAT(USER['REGISTERED']).STRFTIME('%D.%M.%Y')}"""

text
BOT.REPLY_TO(MESSAGE, PROFILE_TEXT, PARSE_MODE='HTML')
COMMAND /TOP
@BOT.MESSAGE_HANDLER(COMMANDS=['TOP'])
DEF TOP_COMMAND(MESSAGE):
TOP_TEXT = USER_SYSTEM.GET_TOP_USERS(10)
BOT.REPLY_TO(MESSAGE, TOP_TEXT, PARSE_MODE='HTML')

COMMAND /GIVE
@BOT.MESSAGE_HANDLER(COMMANDS=['GIVE'])
DEF GIVE_COMMAND(MESSAGE):
TRY:
ARGS = MESSAGE.TEXT.SPLIT()[1:] # SKIP /GIVE

text
    IF LEN(ARGS) != 2:
        BOT.REPLY_TO(MESSAGE, "‚ùå <B>INVALID FORMAT!</B>\NUSE: <CODE>/GIVE [ID] [AMOUNT]</CODE>\NEXAMPLE: <CODE>/GIVE 1001 50.5</CODE>", PARSE_MODE='HTML')
        RETURN
    
    TARGET_ID = INT(ARGS[0])
    AMOUNT = FLOAT(ARGS[1])
    
    RESULT = USER_SYSTEM.TRANSFER_PL(MESSAGE.FROM_USER.ID, TARGET_ID, AMOUNT)
    BOT.REPLY_TO(MESSAGE, RESULT, PARSE_MODE='HTML')

EXCEPT (VALUEERROR, INDEXERROR):
    BOT.REPLY_TO(MESSAGE, "‚ùå <B>INPUT ERROR!</B>\NUSE: <CODE>/GIVE [ID] [AMOUNT]</CODE>\NEXAMPLE: <CODE>/GIVE 1001 50.5</CODE>", PARSE_MODE='HTML')
========== ADMIN COMMANDS ==========
COMMAND /TRIGGERS
@BOT.MESSAGE_HANDLER(COMMANDS=['TRIGGERS'])
DEF TRIGGERS_COMMAND(MESSAGE):
IF NOT IS_ADMIN(MESSAGE.FROM_USER.ID):
BOT.REPLY_TO(MESSAGE, "‚ùå THIS COMMAND IS FOR ADMINISTRATORS ONLY")
RETURN

text
ARGS = MESSAGE.TEXT.SPLIT()[1:] IF LEN(MESSAGE.TEXT.SPLIT()) > 1 ELSE []

IF NOT ARGS:
    # SHOW TRIGGER LIST
    TRIGGERS_LIST = TRIGGER_SYSTEM.GET_TRIGGERS()
    IF TRIGGERS_LIST:
        TEXT = "üìã <B>TRIGGER WORD LIST:</B>\N\N"
        FOR I, TRIGGER IN ENUMERATE(TRIGGERS_LIST, 1):
            TEXT += F"{I}. {TRIGGER}\N"
        TEXT += "\N<B>ADD:</B> /TRIGGERS ADD [WORD]\N<B>REMOVE:</B> /TRIGGERS REMOVE [WORD]"
    ELSE:
        TEXT = "üì≠ TRIGGER LIST IS EMPTY"
    
    BOT.REPLY_TO(MESSAGE, TEXT, PARSE_MODE='HTML')
    RETURN

ACTION = ARGS[0].LOWER()

IF ACTION == 'ADD' AND LEN(ARGS) > 1:
    NEW_TRIGGER = ' '.JOIN(ARGS[1:])
    IF TRIGGER_SYSTEM.ADD_TRIGGER(NEW_TRIGGER):
        BOT.REPLY_TO(MESSAGE, F"‚úÖ TRIGGER '{NEW_TRIGGER}' ADDED")
    ELSE:
        BOT.REPLY_TO(MESSAGE, F"‚ö†Ô∏è TRIGGER '{NEW_TRIGGER}' ALREADY EXISTS")

ELIF ACTION == 'REMOVE' AND LEN(ARGS) > 1:
    TRIGGER_TO_REMOVE = ' '.JOIN(ARGS[1:])
    IF TRIGGER_SYSTEM.REMOVE_TRIGGER(TRIGGER_TO_REMOVE):
        BOT.REPLY_TO(MESSAGE, F"‚úÖ TRIGGER '{TRIGGER_TO_REMOVE}' REMOVED")
    ELSE:
        BOT.REPLY_TO(MESSAGE, F"‚ùå TRIGGER '{TRIGGER_TO_REMOVE}' NOT FOUND")

ELSE:
    BOT.REPLY_TO(MESSAGE, "‚ùå UNKNOWN COMMAND. USE:\N/TRIGGERS - LIST\N/TRIGGERS ADD [WORD] - ADD\N/TRIGGERS REMOVE [WORD] - REMOVE")
COMMAND /WARNINGS
@BOT.MESSAGE_HANDLER(COMMANDS=['WARNINGS'])
DEF WARNINGS_COMMAND(MESSAGE):
IF NOT IS_ADMIN(MESSAGE.FROM_USER.ID):
BOT.REPLY_TO(MESSAGE, "‚ùå THIS COMMAND IS FOR ADMINISTRATORS ONLY")
RETURN

text
ARGS = MESSAGE.TEXT.SPLIT()[1:] IF LEN(MESSAGE.TEXT.SPLIT()) > 1 ELSE []

IF NOT ARGS:
    # SHOW WARNING STATISTICS
    WARNINGS_DATA = TRIGGER_SYSTEM.WARNINGS
    
    IF NOT WARNINGS_DATA:
        BOT.REPLY_TO(MESSAGE, "üì≠ NO ACTIVE WARNINGS")
        RETURN
    
    TEXT = "‚ö†Ô∏è <B>USERS WITH WARNINGS:</B>\N\N"
    
    FOR USER_ID_STR, DATA IN LIST(WARNINGS_DATA.ITEMS())[:20]:  # LIMIT OUTPUT
        COUNT = DATA['COUNT']
        TEXT += F"ID: {USER_ID_STR} - {COUNT} WARNINGS\N"
    
    IF LEN(WARNINGS_DATA) > 20:
        TEXT += F"\N... AND {LEN(WARNINGS_DATA) - 20} MORE USERS"
    
    BOT.REPLY_TO(MESSAGE, TEXT, PARSE_MODE='HTML')
    RETURN

# CHECK WARNINGS FOR SPECIFIC USER
USER_MENTION = ARGS[0]

# PARSE USER ID FROM MENTION
IF USER_MENTION.STARTSWITH('@'):
    # NEED TO FIND USER ID BY USERNAME
    # IN REAL BOT NEED TO IMPLEMENT SEARCH
    BOT.REPLY_TO(MESSAGE, "‚ö†Ô∏è USERNAME SEARCH NOT IMPLEMENTED YET. USE USER ID.")
    RETURN
ELSE:
    TRY:
        USER_ID = INT(USER_MENTION)
        WARNINGS = TRIGGER_SYSTEM.GET_WARNINGS(USER_ID)
        
        IF WARNINGS['COUNT'] > 0:
            TEXT = F"‚ö†Ô∏è <B>WARNINGS FOR USER {USER_ID}:</B>\N\N"
            TEXT += F"COUNT: {WARNINGS['COUNT']}\N"
            
            IF WARNINGS['HISTORY']:
                TEXT += "\N<B>HISTORY:</B>\N"
                FOR WARN IN WARNINGS['HISTORY'][-5:]:  # LAST 5
                    TIME_STR = DATETIME.FROMTIMESTAMP(WARN['TIME']).STRFTIME('%D.%M.%Y %H:%M')
                    TEXT += F"‚Ä¢ {TIME_STR}: {WARN['REASON']}\N"
            
            TEXT += F"\N<B>RESET:</B> /RESET_WARNINGS {USER_ID}"
        ELSE:
            TEXT = F"‚úÖ USER {USER_ID} HAS NO WARNINGS"
        
        BOT.REPLY_TO(MESSAGE, TEXT, PARSE_MODE='HTML')
    
    EXCEPT VALUERROR:
        BOT.REPLY_TO(MESSAGE, "‚ùå INVALID USER ID FORMAT")
COMMAND /RESET_WARNINGS
@BOT.MESSAGE_HANDLER(COMMANDS=['RESET_WARNINGS'])
DEF RESET_WARNINGS_COMMAND(MESSAGE):
IF NOT IS_ADMIN(MESSAGE.FROM_USER.ID):
BOT.REPLY_TO(MESSAGE, "‚ùå THIS COMMAND IS FOR ADMINISTRATORS ONLY")
RETURN

text
ARGS = MESSAGE.TEXT.SPLIT()[1:] IF LEN(MESSAGE.TEXT.SPLIT()) > 1 ELSE []

IF NOT ARGS:
    BOT.REPLY_TO(MESSAGE, "‚ùå SPECIFY USER ID: /RESET_WARNINGS [ID]")
    RETURN

TRY:
    USER_ID = INT(ARGS[0])
    IF TRIGGER_SYSTEM.RESET_WARNINGS(USER_ID):
        BOT.REPLY_TO(MESSAGE, F"‚úÖ WARNINGS FOR USER {USER_ID} RESET")
    ELSE:
        BOT.REPLY_TO(MESSAGE, F"‚ö†Ô∏è USER {USER_ID} HAS NO WARNINGS")
EXCEPT VALUERROR:
    BOT.REPLY_TO(MESSAGE, "‚ùå INVALID USER ID FORMAT")
COMMAND /BAN
@BOT.MESSAGE_HANDLER(COMMANDS=['BAN'])
DEF BAN_COMMAND(MESSAGE):
IF NOT IS_ADMIN(MESSAGE.FROM_USER.ID):
BOT.REPLY_TO(MESSAGE, "‚ùå THIS COMMAND IS FOR ADMINISTRATORS ONLY")
RETURN

text
IF MESSAGE.CHAT.TYPE NOT IN ['GROUP', 'SUPERGROUP']:
    BOT.REPLY_TO(MESSAGE, "‚ùå THIS COMMAND WORKS ONLY IN GROUPS")
    RETURN

IF NOT MESSAGE.REPLY_TO_MESSAGE:
    BOT.REPLY_TO(MESSAGE, "‚ùå REPLY TO USER MESSAGE TO BAN")
    RETURN

TARGET_USER = MESSAGE.REPLY_TO_MESSAGE.FROM_USER

TRY:
    # BAN IN CHAT
    BOT.BAN_CHAT_MEMBER(
        CHAT_ID=MESSAGE.CHAT.ID,
        USER_ID=TARGET_USER.ID,
        UNTIL_DATE=INT(TIME.TIME()) + BAN_DURATION
    )
    
    # RESET WARNINGS
    TRIGGER_SYSTEM.RESET_WARNINGS(TARGET_USER.ID)
    
    BOT.REPLY_TO(MESSAGE, F"‚úÖ USER @{TARGET_USER.USERNAME OR TARGET_USER.ID} BANNED FOR 1 HOUR")

EXCEPT EXCEPTION AS E:
    BOT.REPLY_TO(MESSAGE, F"‚ùå BAN ERROR: {STR(E)}")
========== MESSAGE HANDLING IN PLAZCHAT CHAT ==========
@BOT.MESSAGE_HANDLER(FUNC=LAMBDA M: M.CHAT.ID == PLAZCHAT_CHAT_ID)
DEF HANDLE_PLAZCHAT_MESSAGE(MESSAGE):
# IGNORE COMMANDS WITH / (THEY ARE HANDLED BY OTHER HANDLERS)
IF MESSAGE.TEXT AND MESSAGE.TEXT.STARTSWITH('/'):
RETURN

text
USER_ID = MESSAGE.FROM_USER.ID

# ANTI-FLOOD CHECK
IF NOT USER_SYSTEM.ANTI_FLOOD(USER_ID):
    RETURN

# 1. AWARD PL FOR MESSAGE
NEW_BALANCE = USER_SYSTEM.ADD_MESSAGE(USER_ID)

# 2. CHECK FOR TRIGGER WORDS
FOUND_TRIGGERS = TRIGGER_SYSTEM.CHECK_MESSAGE(MESSAGE)

IF FOUND_TRIGGERS:
    # DELETE MESSAGE
    TRY:
        BOT.DELETE_MESSAGE(MESSAGE.CHAT.ID, MESSAGE.MESSAGE_ID)
    EXCEPT:
        PASS
    
    # ADD WARNING
    WARNING_COUNT = TRIGGER_SYSTEM.ADD_WARNING(USER_ID)
    
    # FORM WARNING MESSAGE
    WARNING_MSG = F"""‚ö†Ô∏è <B>WARNING!</B>
USER: @{MESSAGE.FROM_USER.USERNAME OR MESSAGE.FROM_USER.ID}
VIOLATION: TRIGGER WORDS DETECTED
WORDS: {', '.JOIN(FOUND_TRIGGERS)}

<B>WARNING {WARNING_COUNT}/{WARNINGS_LIMIT}</B>
NEXT VIOLATION MAY LEAD TO BAN!"""

text
    # SEND WARNING
    SENT_MSG = BOT.REPLY_TO(MESSAGE, WARNING_MSG, PARSE_MODE='HTML')
    
    # DELETE WARNING AFTER 10 SECONDS
    TIME.SLEEP(10)
    TRY:
        BOT.DELETE_MESSAGE(MESSAGE.CHAT.ID, SENT_MSG.MESSAGE_ID)
    EXCEPT:
        PASS
    
    # IF WARNING LIMIT EXCEEDED - BAN
    IF WARNING_COUNT >= WARNINGS_LIMIT:
        TRY:
            BOT.BAN_CHAT_MEMBER(
                CHAT_ID=MESSAGE.CHAT.ID,
                USER_ID=USER_ID,
                UNTIL_DATE=INT(TIME.TIME()) + BAN_DURATION
            )
            
            BAN_MSG = F"‚õîÔ∏è USER @{MESSAGE.FROM_USER.USERNAME OR USER_ID} BANNED FOR VIOLATIONS!"
            BOT.SEND_MESSAGE(MESSAGE.CHAT.ID, BAN_MSG, PARSE_MODE='HTML')
            
            # RESET WARNINGS
            TRIGGER_SYSTEM.RESET_WARNINGS(USER_ID)
        
        EXCEPT EXCEPTION AS E:
            PRINT(F"BAN ERROR: {E}")
    
    RETURN

# 3. HANDLE TEXT COMMANDS
IF MESSAGE.TEXT:
    TEXT = MESSAGE.TEXT.LOWER().STRIP()
    
    # PROFILE
    IF TEXT == 'PROFILE':
        USER = USER_SYSTEM.GET_OR_CREATE_USER(
            USER_ID,
            MESSAGE.FROM_USER.USERNAME OR MESSAGE.FROM_USER.FIRST_NAME
        )
        
        PROFILE_TEXT = F"""<B>üë§ CHAT PROFILE</B>
üöµ‚Äç‚ôÄÔ∏è <B>NICKNAME:</B> {USER['USERNAME']}
ü™™ <B>ID:</B> {USER['USER_ID']}
üí∑ <B>PL:</B> {USER['PL']:.2F}
üí¨ <B>MESSAGES:</B> {USER['MESSAGES']}
üé≥ <B>STRIKES:</B> {USER['STRIKES']}"""

text
        BOT.REPLY_TO(MESSAGE, PROFILE_TEXT, PARSE_MODE='HTML')
    
    # TOP
    ELIF TEXT == 'TOP':
        TOP_TEXT = USER_SYSTEM.GET_TOP_USERS(5)
        BOT.REPLY_TO(MESSAGE, TOP_TEXT, PARSE_MODE='HTML')
    
    # BALANCE
    ELIF TEXT == 'BALANCE':
        USER = USER_SYSTEM.GET_OR_CREATE_USER(USER_ID)
        BALANCE_TEXT = F"""üí∑ <B>YOUR PL BALANCE:</B> {USER['PL']:.2F}
üìà <B>MESSAGES:</B> {USER['MESSAGES']}
üéØ <B>TO PL:</B> {MAX(0, 100 - USER['MESSAGES'])}"""

text
        BOT.REPLY_TO(MESSAGE, BALANCE_TEXT, PARSE_MODE='HTML')
    
    # USER INFO (BY REPLY)
    ELIF TEXT == 'INFO' AND MESSAGE.REPLY_TO_MESSAGE:
        TARGET_USER = MESSAGE.REPLY_TO_MESSAGE.FROM_USER
        USER = USER_SYSTEM.GET_OR_CREATE_USER(
            TARGET_USER.ID,
            TARGET_USER.USERNAME OR TARGET_USER.FIRST_NAME
        )
        
        INFO_TEXT = F"""<B>üìä USER INFORMATION</B>
üë§ <B>NICKNAME:</B> {USER['USERNAME']}
ü™™ <B>ID:</B> {USER['USER_ID']}
üí∑ <B>PL:</B> {USER['PL']:.2F}
üí¨ <B>MESSAGES:</B> {USER['MESSAGES']}
üìÖ <B>ACTIVE:</B> {DATETIME.FROMTIMESTAMP(USER['LAST_ACTIVE']).STRFTIME('%D.%M.%Y')}"""

text
        BOT.REPLY_TO(MESSAGE, INFO_TEXT, PARSE_MODE='HTML')
    
    # INFO BY ID
    ELIF TEXT.STARTSWITH('INFO '):
        PARTS = TEXT.SPLIT()
        IF LEN(PARTS) >= 2:
            TRY:
                TARGET_ID = INT(PARTS[1])
                
                # FIND USER BY ID
                TARGET_USER_DATA = NONE
                FOR UID, DATA IN USER_SYSTEM.USERS.ITEMS():
                    IF DATA['USER_ID'] == TARGET_ID:
                        TARGET_USER_DATA = DATA
                        BREAK
                
                IF TARGET_USER_DATA:
                    INFO_TEXT = F"""<B>üìä INFORMATION BY ID</B>
üë§ <B>NICKNAME:</B> {TARGET_USER_DATA['USERNAME']}
ü™™ <B>ID:</B> {TARGET_USER_DATA['USER_ID']}
üí∑ <B>PL:</B> {TARGET_USER_DATA['PL']:.2F}
üí¨ <B>MESSAGES:</B> {TARGET_USER_DATA['MESSAGES']}"""
ELSE:
INFO_TEXT = F"‚ùå USER WITH ID {TARGET_ID} NOT FOUND"

text
                BOT.REPLY_TO(MESSAGE, INFO_TEXT, PARSE_MODE='HTML')
            
            EXCEPT VALUERROR:
                BOT.REPLY_TO(MESSAGE, "‚ùå INVALID ID FORMAT")
    
    # PL TRANSFER
    ELIF TEXT.STARTSWITH('TRANSFER '):
        PARTS = TEXT.SPLIT()
        IF LEN(PARTS) >= 3:
            TRY:
                TARGET_ID = INT(PARTS[1])
                AMOUNT = FLOAT(PARTS[2])
                
                RESULT = USER_SYSTEM.TRANSFER_PL(USER_ID, TARGET_ID, AMOUNT)
                BOT.REPLY_TO(MESSAGE, RESULT, PARSE_MODE='HTML')
            
            EXCEPT (VALUERROR, INDEXERROR):
                BOT.REPLY_TO(MESSAGE, "‚ùå INVALID FORMAT. USE: TRANSFER [ID] [AMOUNT]")
    
    # CLAN TRIGGERS
    ELIF TEXT.STARTSWITH('JOIN '):
        CLAN_NAME = TEXT.REPLACE('JOIN ', '', 1).STRIP()
        IF CLAN_NAME:
            RESPONSE = F"""‚úÖ <B>CLAN JOIN REQUEST</B>
üë§ USER: @{MESSAGE.FROM_USER.USERNAME OR MESSAGE.FROM_USER.ID}
üè∞ CLAN: {CLAN_NAME}

REQUEST SENT TO CLAN LEADER.
AWAIT CONFIRMATION."""

text
            BOT.REPLY_TO(MESSAGE, RESPONSE, PARSE_MODE='HTML')
    
    ELIF TEXT.STARTSWITH('LEAVE '):
        CLAN_NAME = TEXT.REPLACE('LEAVE ', '', 1).STRIP()
        IF CLAN_NAME:
            RESPONSE = F"""‚úÖ <B>CLAN LEAVE REQUEST</B>
üë§ USER: @{MESSAGE.FROM_USER.USERNAME OR MESSAGE.FROM_USER.ID}
üè∞ CLAN: {CLAN_NAME}

LEAVE REQUEST SENT."""

text
            BOT.REPLY_TO(MESSAGE, RESPONSE, PARSE_MODE='HTML')
========== PRIVATE MESSAGE HANDLING ==========
@BOT.MESSAGE_HANDLER(FUNC=LAMBDA M: M.CHAT.TYPE == 'PRIVATE')
DEF HANDLE_PRIVATE_MESSAGE(MESSAGE):
# IF MESSAGE IS NOT COMMAND - SEND "UNKNOWN COMMAND"
IF NOT MESSAGE.TEXT OR NOT MESSAGE.TEXT.STARTSWITH('/'):
BOT.REPLY_TO(MESSAGE, "‚ùì UNKNOWN COMMAND. USE /HELP FOR COMMAND LIST")

========== BOT START ==========
IF NAME == "MAIN":
PRINT("ü§ñ PLAZWAR BOT STARTING...")
PRINT(F"üìç MAIN CHAT: {PLAZCHAT_CHAT_ID}")
PRINT(F"üìä USERS: {LEN(USER_SYSTEM.USERS)}")
PRINT(F"‚ö†Ô∏è TRIGGERS: {LEN(TRIGGER_SYSTEM.TRIGGERS)}")
PRINT("=" * 50)

text
# START BOT
TRY:
    BOT.INFINITY_POLLING()
EXCEPT EXCEPTION AS E:
    PRINT(F"‚ùå BOT START ERROR: {E}")
üìö EXPLANATION OF EACH COMPONENT:

DATA STRUCTURE:
USERS.JSON - USER DATA (NICKNAME, MESSAGES, PL, ID)

TRIGGERS.JSON - LIST OF TRIGGER WORDS FOR MODERATION

WARNINGS.JSON - USER WARNING HISTORY

SYSTEM CLASSES:
DATASTORAGE - WORK WITH FILES:
LOAD_JSON() - LOAD DATA FROM JSON

SAVE_JSON() - SAVE DATA TO JSON

TRIGGERSYSTEM - TRIGGER SYSTEM:
CHECK_MESSAGE() - CHECK MESSAGE FOR TRIGGERS

ADD_WARNING() - ADD WARNING

ADD_TRIGGER() / REMOVE_TRIGGER() - TRIGGER MANAGEMENT

USERSYSTEM - USER SYSTEM:
GET_OR_CREATE_USER() - CREATE/GET USER

ADD_MESSAGE() - AWARD PL FOR MESSAGES

TRANSFER_PL() - TRANSFER PL BETWEEN USERS

GET_TOP_USERS() - TOP PLAYERS

ADMIN COMMANDS:
/TRIGGERS - TRIGGER MANAGEMENT

/WARNINGS @USER - VIEW WARNINGS

/BAN @USER - BAN USER (REPLY TO MESSAGE)

/RESET_WARNINGS ID - RESET WARNINGS

WORK LOGIC IN CHAT:
PL AWARDING:
EACH MESSAGE IN PLAZCHAT = +1 TO COUNTER

AFTER 100 MESSAGES = +0.5 PL FOR EACH MESSAGE

ANTI-FLOOD: 2 SECONDS BETWEEN MESSAGES

TRIGGER CHECK:
MESSAGE CHECKED FOR TRIGGER WORDS

IF FOUND - MESSAGE DELETED

USER GETS WARNING

AT 3 WARNINGS - 1 HOUR BAN

TEXT COMMANDS IN CHAT:
PROFILE - SHOW PROFILE

TOP - TOP PLAYERS

BALANCE - PL BALANCE

INFO - INFORMATION (REPLY TO MESSAGE)

INFO [ID] - INFORMATION BY ID

TRANSFER [ID] [AMOUNT] - TRANSFER PL

JOIN [CLAN] - CLAN JOIN REQUEST

LEAVE [CLAN] - CLAN LEAVE REQUEST

COMMANDS IN PRIVATE:
/START - WELCOME

/HELP - HELP

/PROFILE - PROFILE

/TOP - TOP PLAYERS

/GIVE [ID] [AMOUNT] - TRANSFER PL

ALL OTHER MESSAGES = "UNKNOWN COMMAND"

üõ† SETUP:

INSTALL LIBRARIES:
BASH
PIP INSTALL PYTELECGRAMBOTAPI

CONFIGURE:
PYTHON

REPLACE THESE VALUES:
BOT_TOKEN = 'YOUR_TOKEN' # GET FROM @BOTFATHER
PLAZCHAT_CHAT_ID = -1002222950483 # CHAT ID @PLAZCHAT
ADMIN_IDS = [123456789] # YOUR TELEGRAM ID
3. GET CHAT ID:
PYTHON

ADD TEMPORARILY TO CODE:
@BOT.MESSAGE_HANDLER(COMMANDS=['GETID'])
DEF GET_CHAT_ID(MESSAGE):
BOT.REPLY_TO(MESSAGE, F"CHAT ID: {MESSAGE.CHAT.ID}")

START BOT, SEND /GETID IN NEEDED CHAT
DEFAULT TRIGGERS:
JSON
["ADVERTISEMENT", "SPAM", "INSULT", "PROFANITY", "SCAM", "DECEPTION", "FRAUD", "PORNOGRAPHY", "DRUGS", "WEAPONS", "VIOLENCE", "FRAUD"]
üîß HOW TRIGGER SYSTEM WORKS:
EXAMPLE SCENARIO:
USER WRITES: "BUY ADVERTISEMENT FROM ME CHEAP!"

BOT CHECKS: WORD "ADVERTISEMENT" IN TRIGGERS

BOT ACTIONS:

DELETES MESSAGE

ADDS WARNING TO USER

SENDS WARNING (DELETES AFTER 10 SEC)

AT 3 WARNINGS - BAN

ADDING NEW TRIGGERS:
TEXT
ADMIN: /TRIGGERS ADD SCAM
BOT: ‚úÖ TRIGGER 'SCAM' ADDED

ADMIN: /TRIGGERS
BOT: TRIGGER WORD LIST...
üìä WARNING MANAGEMENT:
VIEW:
TEXT
/TRIGGERS - LIST ALL TRIGGERS
/WARNINGS - ALL USERS WITH WARNINGS
/WARNINGS 123456789 - WARNINGS FOR SPECIFIC USER
RESET:
TEXT
/RESET_WARNINGS 123456789 - RESET WARNINGS
‚ö° OPTIMIZATION:
FOR LARGE CHATS:
PYTHON

INCREASE ANTI-FLOOD DELAY
ANTI_FLOOD_DELAY = 1 # 1 SECOND

REDUCE WARNINGS BEFORE BAN
WARNINGS_LIMIT = 2

REDUCE BAN TIME FOR TESTING
BAN_DURATION = 300 # 5 MINUTES
FOR PERFORMANCE:
PYTHON

CACHE TRIGGER CHECK
TRIGGER_CACHE = {}

DEF CHECK_MESSAGE_CACHED(MESSAGE):
TEXT_HASH = HASH(MESSAGE.TEXT)
IF TEXT_HASH IN TRIGGER_CACHE:
RETURN TRIGGER_CACHE[TEXT_HASH]

text
RESULT = TRIGGER_SYSTEM.CHECK_MESSAGE(MESSAGE)
TRIGGER_CACHE[TEXT_HASH] = RESULT
RETURN RESULT
üö® IMPORTANT NOTES:

BOT RIGHTS IN CHAT:
BOT MUST BE ADMINISTRATOR

RIGHTS: DELETE MESSAGES, BAN USERS

TELEGRAM LIMITATIONS:
MAXIMUM 20 MESSAGES PER SECOND FROM BOT

CANNOT BAN ADMINISTRATORS

LIMITATIONS ON DELETING OLD MESSAGES

SECURITY:
KEEP BOT TOKEN SECRET

LIMIT ACCESS TO ADMIN COMMANDS

REGULARLY BACKUP DATA

üìà FUNCTIONALITY EXPANSION:
ADDITIONAL FEATURES:
PYTHON

1. TIME-BASED AUTOMATIC MODERATION
NIGHT_MODE = FALSE # STRICTER MODERATION AT NIGHT

2. SMART TRIGGERS (REGULAR EXPRESSIONS)
SMART_TRIGGERS = [
R"\BBUY(ME)?\B.\BADVERTIS(EMENT)?\B",
R"\BFREE\B.\BMONEY\B"
]

3. REPUTATION SYSTEM
REPUTATION_SYSTEM = {
'GOOD_MESSAGE': +1,
'BAD_MESSAGE': -3,
'BAN_THRESHOLD': -10
}

4. ACTION LOGGING
DEF LOG_ACTION(USER_ID, ACTION, DETAILS):
WITH OPEN('MODERATION.LOG', 'A') AS F:
F.WRITE(F"{DATETIME.NOW()} | {USER_ID} | {ACTION} | {DETAILS}\N")
üêõ ERROR HANDLING:
COMMON ERRORS AND SOLUTIONS:
"CHAT NOT FOUND" - CHECK CHAT ID

"NOT ENOUGH RIGHTS" - GIVE BOT ADMIN RIGHTS

"MESSAGE TO DELETE NOT FOUND" - MESSAGE ALREADY DELETED

"FLOOD CONTROL" - INCREASE DELAY BETWEEN MESSAGES

üéØ TESTING:
TEST COMMANDS:
PYTHON

TRIGGER TESTING
@BOT.MESSAGE_HANDLER(COMMANDS=['TEST_TRIGGER'])
DEF TEST_TRIGGER(MESSAGE):
TEST_MESSAGE = TYPE('OBJ', (OBJECT,), {
'TEXT': 'THIS MESSAGE CONTAINS ADVERTISEMENT',
'FROM_USER': MESSAGE.FROM_USER
})

text
TRIGGERS = TRIGGER_SYSTEM.CHECK_MESSAGE(TEST_MESSAGE)
BOT.REPLY_TO(MESSAGE, F"FOUND TRIGGERS: {TRIGGERS}")
STATISTICS
@BOT.MESSAGE_HANDLER(COMMANDS=['STATS'])
DEF SHOW_STATS(MESSAGE):
STATS = F"""üìä <B>BOT STATISTICS</B>

üë• USERS: {LEN(USER_SYSTEM.USERS)}
‚ö†Ô∏è WARNINGS: {SUM([W['COUNT'] FOR W IN TRIGGER_SYSTEM.WARNINGS.VALUES()])}
üö´ TRIGGERS: {LEN(TRIGGER_SYSTEM.TRIGGERS)}
üíé TOTAL PL IN SYSTEM: {SUM([U['PL'] FOR U IN USER_SYSTEM.USERS.VALUES()]):.2F}"""

text
BOT.REPLY_TO(MESSAGE, STATS, PARSE_MODE='HTML')
üöÄ SYSTEM READY FOR USE! JUST CONFIGURE AND START BOT.
